# 패러다임 개요
무엇을 해야할지에 대해 말하기보다는 무엇은 해서는 안 될지를 말해줌
-> 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과함

## 구조적 프로그래밍
- 1968년 데이크스트라가 발견-> 수학적인 증명을 통해 해결하고자 함
- 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다
- if/then/else, do/while/until과같은 구조로 대체해서 사용함
- **제어흐름의 직접적인 전환에 대해 규칙을 부과한다**

1. Sequence(순차) : 입력에서부터 출력까지 수학적으로 추적함
2. Selection(분기) : 분기를 통한 경로 열거. 두 경로가 적절한 결과를 만들어 낼 경우 신뢰함
3. Iteration(반복) : 반복이 올바른지 확인하기 위해 귀납법(induction)을 사용함. n의 경우가 맞을 때 -> n+1도 맞음

- 1970년대 후반에서 1980년대에 걸쳐 인기를 끌었음
- 구조적 분석과 구조적 설계는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 이를 입증할 수 있는 기능으로 세분화 가능
- **소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트 하기 쉽도록) 만들기 위해 부준히 노력해야 함**

## 객체 지향 프로그래밍
- 1966년 올레 요한 달, 크리스텐 니가드에 의해 등장
- 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오래 유지될 수 있음을 발견
- 함수: class의 생성자 / 지역 변수: 인스턴스 변수 / 중첩 함수: 메서드
- **제어흐름의 간접적인 전환에 대해 규칙을 부과한다**

#### 캡슐화
- 데이터는 은닉되고,일부 함수만 외부에 노출됨
- public, private, protected 키워드 도입을 통해 불완전한 캡슐화를 어느정도 보완함
- 하지만, 컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 하기 때문에 임시방편일뿐임

#### 상속화
(공부중)

## 함수형 프로그래밍
- 1958년 존 매카시가 만든 LISP 언어의 근간이 되는 개념: 람다 계산법
- 람다 계산법은 불변성으로 심볼 값이 변경되지 않음(함수형언어에는할당문이 전혀 없음)
- **함수형 프로그래밍은 할당문에 대해 규칙을 부과한다**
